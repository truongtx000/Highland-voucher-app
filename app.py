import streamlit as st
from itertools import combinations

# C·∫•u h√¨nh giao di·ªán
st.set_page_config(page_title="Highland Voucher App", layout="centered")

# --- CSS t√πy ch·ªânh ---
st.markdown("""
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Condensed&display=swap');

        html, body, [class*="css"]  {
            font-family: 'Roboto Condensed', sans-serif;
            background-color: #FFFDF1;
        }

        .main > div {
            padding: 0 !important;
        }

        .title-container {
            background-color: #AA1F24;
            color: white;
            text-align: center;
            padding: 2rem 1rem 1rem;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
        }

        .block-container {
            padding-top: 0 !important;
        }

        .input-card {
            background-color: #fff;
            padding: 1rem;
            border-radius: 0 0 8px 8px;
        }

        .submit-button button {
            background-color: #AA1F24 !important;
            color: white !important;
            font-weight: bold;
        }
    </style>
""", unsafe_allow_html=True)

# --- Ti√™u ƒë·ªÅ ---
st.markdown("""
<div class="title-container">
    <h2>Ti·∫øt Ki·ªám Highland<br>C√πng Voucher</h2>
</div>
""", unsafe_allow_html=True)

# --- Kh·ªëi nh·∫≠p li·ªáu ---
st.markdown("<div class='input-card'>", unsafe_allow_html=True)

col1, col2 = st.columns([1, 1])
with col1:
    st.markdown("""<h4>üõçÔ∏è Nh·∫≠p danh s√°ch m√≥n</h4>
<p>Nh·∫≠p t√™n v√† gi√° t·ª´ng m√≥n, m·ªói d√≤ng 1 m√≥n (vd: cf s·ªØa m, 39)</p>""", unsafe_allow_html=True)
    items_input = st.text_area("", height=150, label_visibility="collapsed")

with col2:
    st.markdown("""<h4>üéÅ Nh·∫≠p danh s√°ch voucher</h4>
<p>Nh·∫≠p m·ªói voucher theo d·∫°ng: min_price, discount</p>""", unsafe_allow_html=True)
    voucher_input = st.text_area("", height=150, label_visibility="collapsed")

st.markdown("</div>", unsafe_allow_html=True)

# --- Parse d·ªØ li·ªáu ---
def parse_items(text):
    lines = text.strip().split("\n")
    items = []
    for i, line in enumerate(lines):
        if "," in line:
            name, price_str = line.rsplit(",", 1)
            try:
                price = int(price_str.strip())
                items.append({"id": i, "name": name.strip(), "price": price})
            except ValueError:
                st.warning(f"‚ùó L·ªói ƒë·ªãnh d·∫°ng gi√° ·ªü d√≤ng: '{line}'. Vui l√≤ng nh·∫≠p s·ªë nguy√™n.")
        elif line.strip():
            st.warning(f"‚ùó ƒê·ªãnh d·∫°ng kh√¥ng ƒë√∫ng ·ªü d√≤ng: '{line}'. Vui l√≤ng nh·∫≠p theo d·∫°ng 't√™n, gi√°'.")
    return items

def parse_vouchers(text):
    lines = text.strip().split("\n")
    vouchers = []
    for i, line in enumerate(lines):
        if "," in line:
            try:
                min_total, discount = map(int, line.strip().split(","))
                vouchers.append({"id": i, "min_total": min_total, "discount": discount,
                                 "label": f"üéÅ ({min_total}k -{discount}k)"})
            except ValueError:
                st.warning(f"‚ùó L·ªói ƒë·ªãnh d·∫°ng voucher ·ªü d√≤ng: '{line}'. Vui l√≤ng nh·∫≠p theo d·∫°ng 'min_total,discount'.")
        elif line.strip():
            st.warning(f"‚ùó ƒê·ªãnh d·∫°ng kh√¥ng ƒë√∫ng ·ªü d√≤ng: '{line}'. Vui l√≤ng nh·∫≠p theo d·∫°ng 'min_total,discount'.")
    return vouchers

# --- T·ªëi ∆∞u ---
def find_optimal_voucher_distribution(items, vouchers):
    best_total_cost = float('inf')
    best_solution_details = []

    item_indices = list(range(len(items)))

    def recurse(remaining_indices, voucher_index, current_groups):
        nonlocal best_total_cost, best_solution_details

        if voucher_index == len(vouchers):
            leftover_cost = sum(items[i]['price'] for i in remaining_indices)
            total = sum(g['final'] for g in current_groups) + leftover_cost
            if total < best_total_cost:
                best_total_cost = total
                result = current_groups[:]
                if remaining_indices:
                    result.append({
                        "voucher": None,
                        "items": [items[i] for i in remaining_indices],
                        "total": leftover_cost,
                        "final": leftover_cost
                    })
                best_solution_details = result
            return

        recurse(remaining_indices, voucher_index + 1, current_groups[:])

        current_voucher = vouchers[voucher_index]
        for r in range(1, len(remaining_indices)+1):
            for combo in combinations(remaining_indices, r):
                selected_items = [items[i] for i in combo]
                group_total = sum(i['price'] for i in selected_items)
                if group_total >= current_voucher['min_total']:
                    next_remaining = [i for i in remaining_indices if i not in combo]
                    new_group = current_groups + [{
                        "voucher": current_voucher,
                        "items": selected_items,
                        "total": group_total,
                        "final": group_total - current_voucher['discount']
                    }]
                    recurse(next_remaining, voucher_index + 1, new_group)

    recurse(item_indices, 0, [])
    return best_solution_details, best_total_cost

# --- X·ª≠ l√Ω khi nh·∫•n n√∫t ---
st.markdown("<div class='submit-button'>", unsafe_allow_html=True)
if st.button("T√≠nh k·∫øt qu·∫£ t·ªëi ∆∞u"):
    items = parse_items(items_input)
    vouchers = parse_vouchers(voucher_input)

    if not items:
        st.warning("‚ùó Vui l√≤ng nh·∫≠p √≠t nh·∫•t 1 m√≥n.")
    elif not vouchers:
        st.warning("‚ùó Vui l√≤ng nh·∫≠p √≠t nh·∫•t 1 voucher.")
    else:
        results, total_cost = find_optimal_voucher_distribution(items, vouchers)

        st.subheader("üìÑ K·∫æT QU·∫¢ T·ªêI ∆ØU")
        for idx, group in enumerate(results, 1):
            if group['voucher']:
                st.markdown(f"**Nh√≥m {idx}** {group['voucher']['label']} _(T·ªïng: {group['total']}k ‚Üí {group['final']}k)_")
            else:
                st.markdown(f"**Nh√≥m {idx}** _(Kh√¥ng d√πng voucher)_ _(T·ªïng: {group['total']}k)_")
            for item in group['items']:
                st.markdown(f"- {item['name']} ({item['price']}k)")

        original_total = sum(i['price'] for i in items)
        st.success(f"‚úÖ T·ªïng chi ph√≠ sau gi·∫£m gi√°: **{total_cost}k** (gi·∫£m ƒë∆∞·ª£c **{original_total - total_cost}k**) ")

st.markdown("</div>", unsafe_allow_html=True)
